Promise promise;                       //on function creation
//Resumable resumable = promise.get_return_object(); called somewhere here
co_await promise.initial_suspend();    //suspend the coroutine and return control to the caller, giving it the Resumable object
						
try {             
  // co-routine body
  co_await expression; //-> co_await promise.await_transform(expression); -> returns an Awaitable object which should have operator co_await() -> returns an Awaiter object
  co_await Awaitable{}; //-> co_await promise.await_transform(Awaitable{}); -> returns an Awaiter object
  co_yield expression; //-> co_await promise.yield_value(expression); -> yield_value stores the value and returns an awaitable object to co_await, the coro is suspended here
  co_return; //-> promise.return_void(); goto final_suspend;
  co_return expression; // -> promise.return_value(expression); goto final_suspend;
}
catch(...) {
  promise.unhandled_exception(); 
}
 
final_suspend:				
  co_await promise.final_suspend();     //suspend the coroutine and make it DONE but NOT DESTROYED (FINISHED) YET 

//if the flow reaches this line, the coroutine is DESTROYED, calling members on its handle is UB


----------------------------------------------------------------------------------------------
co_await expression; generates the following code: 
(when written explicitly, not generated by co_yield, co_return, initial/final suspension)

template <typename T>
concept Awaitable = requires(T&& x) {
  { co_await x; } -> Awaiter auto&& // returns the Awaiter object. If not present (either as member or freestanding function), Awaitable becomes Awaiter
}

template <typename T>
concept Awaiter = requires(T&& x) {
  { x.await_ready() } -> bool; //is there a need for suspension? suspended if await_ready returns false
  { x.await_suspend(coro_handle_t) }; //executed after suspending the coro, decides who gets the control after suspension (via the return type); here 
                                        coro_handle_t is the type of the handle to the current coroutine
  { x.await_resume() } -> co_await_return_t; //called after the coro is resumed, its return value is what the co_await expression evaluates to
}

co_await expr =>
co_await promise.await_transform(expr) =>
co_await Awaitable{} =>
co_await (Awaitable{}.operator co_await()) =>
co_await Awaiter{} =>


std::exception_ptr exception = nullptr;
if (!awaiter.await_ready()) {  //if the awaitable is not done, thus work will be done when resumed
  suspend_coroutine(); //save coro's context to the activation block
  
  //call awaiter.await_suspend(coro_handle)
  //to decide who takes control after suspension:

  //if await_suspend returns void
  //coro stays suspended and control is given back to the caller
  try {
    awaiter.await_suspend(coroutine_handle);
    return_to_the_caller();
  } catch (...) {
    exception = std::current_exception();
    goto resume_point;
  }
  //endif
  
  //else if await_suspend returns bool
  //this means coro might decide to continue execution
  //based on sth in awaiter.await_suspend();
  bool should_suspend = false;
  try {
    should_suspend = awaiter.await_suspend(coroutine_handle);
  } catch (...) {
    exception = std::current_exception();
    goto resume_point;
  }
  if (!should_suspend) {
    goto resume_point;
  } 
  else {
    return_to_the_caller();
  }
  //endif
  

  //if await_suspend returns another coroutine_handle
  //then control is given to the corresponding coroutine
  //std::noop_coroutine_handle for caller
  //id(coro_handle) to actually not suspend
  using coro_return_handle_t = decltype(awaiter.await_suspend(std::declval<coro_handle_t>()));
  coro_return_handle_t another_coro_handle;
  try {
    another_coro_handle = awaiter.await_suspend(coroutine_handle);
  } catch (...) {
    exception = std::current_exception();
    goto resume_point;
  }
  another_coro_handle.resume(); //another_coro is resumed and takes control 
  return_to_the_caller();       //when control is given back to us, return to caller
  //endif

}

resume_point:
if(exception) { //if an exception was thrown while suspending the coro
  std::rethrow_exception(exception);  //propagate it to the caller
} 
else {
  return awaiter.await_resume();  //called when resumed, the return value of await_resume is 
}                                 //the resulting value of the `co_await expr` expression